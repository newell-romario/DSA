








static void test_r2_graph_strongly_connected_components()
{
        r2_uint64 vertices[] = {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'};
        struct r2_graph *graph = r2_create_graph(vcmp, NULL, NULL, NULL, NULL);
        for(r2_uint64 i = 0; i < 8; ++i)
                graph = r2_graph_add_vertex(graph, &vertices[i], sizeof(r2_uint64));
        

        r2_uint64 edges [][2] = {
                {'a', 'b'}, 
                {'b', 'c'}, 
                {'c', 'd'},
                {'d', 'c'},
                {'d', 'h'}, 
                {'h', 'h'},
                {'c', 'g'}, 
                {'g', 'f'}, 
                {'f', 'g'}, 
                {'e', 'a'}, 
                {'e', 'f'},
                {'b', 'e'}
        };  

        for(r2_uint64 i = 0; i < 12; ++i)
                graph = r2_graph_add_edge(graph, &edges[i][0], sizeof(r2_uint64), &edges[i][1], sizeof(r2_uint64), 0);   

        struct r2_components* forest =   r2_graph_strongly_connected_components(graph);
        for(r2_uint16 i = 0; i < forest->ncount; ++i){
                printf("\nStrongly Connected Component %d: ", i);
                print_dfstree(forest->cc[i]);
        }

        assert(forest->ncount == 4);
        struct r2_dfstree *tree = forest->cc[0];
        struct r2_dfsnode *root = r2_graph_dfsnode_first(tree);

        
        tree = forest->cc[0]; 
        root = r2_graph_dfsnode_first(tree);
        assert(*(root->vertex->vkey) == 'a'); 
        root = r2_graph_dfsnode_next(tree, root); 
        assert(*(root->vertex->vkey) == 'e');
        root = r2_graph_dfsnode_next(tree, root); 
        assert(*(root->vertex->vkey) == 'b');
        root = r2_graph_dfsnode_next(tree,root); 
        assert(root == NULL);

        tree = forest->cc[1]; 
        root = r2_graph_dfsnode_first(tree);
        assert(*(root->vertex->vkey) == 'c'); 
        root = r2_graph_dfsnode_next(tree, root); 
        assert(*(root->vertex->vkey) == 'd');
        root = r2_graph_dfsnode_next(tree,root); 

        tree = forest->cc[2]; 
        root = r2_graph_dfsnode_first(tree);
        assert(*(root->vertex->vkey) == 'g'); 
        root = r2_graph_dfsnode_next(tree,root); 
        assert(*(root->vertex->vkey) == 'f');
        root = r2_graph_dfsnode_next(tree,root); 
        assert(root == NULL);

        tree = forest->cc[3]; 
        root = r2_graph_dfsnode_first(tree);
        assert(*(root->vertex->vkey) == 'h');
        root = r2_graph_dfsnode_next(tree, root);
        assert(root == NULL);


        r2_destroy_graph(graph);  
        r2_graph_destroy_components(forest);

        graph  = r2_create_graph(vcmp, NULL, NULL, NULL, NULL);
        r2_uint64 edge [][2] = {
                {'0', '1'}, 
                {'1', '2'}, 
                {'2', '3'},
                {'3', '0'},
                {'4', '5'},
                {'5', '6'},
                {'6', '4'}, 
                {'6', '7'}
        }; 

        for(r2_uint64 i = 0; i < 8; ++i)
                graph = r2_graph_add_edge(graph, &edge[i][0], sizeof(r2_uint64), &edge[i][1], sizeof(r2_uint64), 0);   

        forest = r2_graph_strongly_connected_components(graph);
        assert(forest->ncount == 3);
        for(r2_uint16 i = 0; i < forest->ncount; ++i){
                printf("\nStrongly Connected Component 2 %d: ", i);
                print_dfstree(forest->cc[i]);
        }

        
        tree = forest->cc[0];
        root = r2_graph_dfsnode_first(tree);
        assert(*(root->vertex->vkey) == '4');
        root = r2_graph_dfsnode_next(tree, root);
        assert(*(root->vertex->vkey) == '6');
        root = r2_graph_dfsnode_next(tree, root);
        assert(*(root->vertex->vkey) == '5');
        root = r2_graph_dfsnode_next(tree, root);
        assert(root == NULL);

        tree = forest->cc[1];
        root = r2_graph_dfsnode_first(tree);
        assert(*(root->vertex->vkey) == '7');
        root = r2_graph_dfsnode_next(tree, root);
        assert(root == NULL);

        tree = forest->cc[2];
        root = r2_graph_dfsnode_first(tree);
        assert(*(root->vertex->vkey) == '0');
        root = r2_graph_dfsnode_next(tree, root);
        assert(*(root->vertex->vkey) == '3');
        root = r2_graph_dfsnode_next(tree, root);
        assert(*(root->vertex->vkey) == '2');
        root = r2_graph_dfsnode_next(tree, root);
        assert(*(root->vertex->vkey) == '1');
        root = r2_graph_dfsnode_next(tree, root);
        assert(root == NULL);



        r2_destroy_graph(graph);  
        r2_graph_destroy_components(forest);        
}



static void test_r2_graph_dijkstra()
{
        struct r2_graph *graph = r2_create_graph(vcmp, NULL, NULL, NULL, NULL);
        r2_uint64 edges [][2] = {
                {'s', 't'}, //10
                {'s', 'y'}, //5
                {'t', 'x'}, //1
                {'t', 'y'}, //2
                {'y', 't'}, //3
                {'y', 'z'}, //2
                {'y', 'x'}, //9
                {'x', 'z'}, //4
                {'z', 'x'}, //6
                {'z', 's'} //7
        };

        r2_ldbl weight [] = {10, 5, 1, 2, 3, 2, 9, 4, 6, 7};
        
        for(r2_uint64 i = 0; i < 10;++i)
                graph = r2_graph_add_edge(graph, &edges[i][0], sizeof(r2_uint64), &edges[i][1], sizeof(r2_uint64), weight[i]);  

        struct r2_dfstree *dfs = r2_graph_dijkstra(graph, &edges[0][0], sizeof(r2_uint64), relax);
        print_dfstree_distances(dfs);

        struct r2_dfsnode *root = NULL;
        struct r2_entry entry   = {.key = NULL, .data = NULL, .length = 0};
        r2_uint64 vertex[5] = {'s', 't', 'y', 'x', 'z'};
        r2_ldbl   distances[5] = {0, 8, 5, 9, 7};
        for(r2_uint64 i = 0; i < 5; ++i){
                r2_robintable_get(dfs->positions, &vertex[i], sizeof(r2_uint64), &entry);
                root = entry.data;
                assert(root->dist == distances[i]);
        }

        weight[0] = 3; 
        weight[1] = 5;
        weight[2] = 6;
        weight[3] = 2; 
        weight[4] = 1;
        weight[5] = 6;
        weight[6] = 4; 
        weight[7] = 2; 
        weight[8] = 7; 
        weight[9] = 2; 
        r2_destroy_dfs_tree(dfs);
        r2_destroy_graph(graph);
        graph = r2_create_graph(vcmp, NULL, NULL, NULL, NULL);
        for(r2_uint64 i = 0; i < 10;++i)
                graph = r2_graph_add_edge(graph, &edges[i][0], sizeof(r2_uint64), &edges[i][1], sizeof(r2_uint64), weight[i]);  


        dfs = r2_graph_dijkstra(graph, &edges[0][0], sizeof(r2_uint64), relax);
        print_dfstree_distances(dfs);
        distances[0] = 0; 
        distances[1] = 3; 
        distances[2] = 5; 
        distances[3] = 9;
        distances[4] = 11;
        for(r2_uint64 i = 0; i < 5; ++i){
                r2_robintable_get(dfs->positions, &vertex[i], sizeof(r2_uint64), &entry);
                root = entry.data;
                assert(root->dist == distances[i]);
        }
        r2_destroy_dfs_tree(dfs);
        r2_destroy_graph(graph);    
}

static void test_r2_graph_large_network()
{
        struct r2_graph *graph = r2_create_graph(vcmp, NULL, NULL, NULL, NULL);
        struct r2_vertex *vertex[2];  
        FILE *fp = fopen("roadNet-CA.txt", "r");
        r2_uint64 vertices[2];
        r2_uint64 *src  = NULL;
        r2_uint64 *dest = NULL;

        while(fscanf(fp, "%lld\t%lld", &vertices[0], &vertices[1]) == 2){
                vertex[0] = r2_graph_get_vertex(graph, &vertices[0], sizeof(r2_uint64));
                vertex[1] = r2_graph_get_vertex(graph, &vertices[1], sizeof(r2_uint64));
                if(vertex[0] == NULL){
                        src  = malloc(sizeof(r2_uint64));
                        assert(src != NULL);
                        *src = vertices[0];
                }else
                        src = vertex[0]->vkey;

                if(vertex[1] == NULL){
                        dest = malloc(sizeof(r2_uint64));
                        assert(dest != NULL);
                        *dest = vertices[1];
                }else 
                        dest = vertex[1]->vkey;

              //  printf("\n%lld => %lld", *src, *dest);
                graph = r2_graph_add_edge(graph, src, sizeof(r2_uint64), dest, sizeof(r2_uint64), 0);
        } 

        r2_uint64 s = 0;
        struct r2_dfstree *dfs = r2_graph_dfs_tree(graph, r2_graph_get_vertex(graph, &s, sizeof(r2_uint64)));
        struct r2_bfstree *bfs = r2_graph_bfs_tree(graph, r2_graph_get_vertex(graph, &s, sizeof(r2_uint64)));

        struct r2_components *scc = r2_graph_strongly_connected_components(graph);
        r2_uint64 largest = 0;
        r2_uint64 pos = 0 ; 
        for(r2_uint64 i = 0; i < scc->ncount; ++i){
                if(scc->cc[i]->ncount > largest){
                        largest = scc->cc[i]->ncount;
                        pos = i;
                }
        } 

        printf("\nNumber of nodes in largest component: %ld", largest);
        fclose(fp);
        r2_destroy_graph(graph);      
}












static void print_edges(struct r2_vertex *vertex)
{
        struct r2_edge     *edge = NULL;
        struct r2_listnode *node = r2_listnode_first(vertex->elist); 
        while(node != NULL){
                edge = node->data; 
                printf(" [%d, %d]", *(r2_uint64 *)edge->src->vkey, *(r2_uint64 *)edge->dest->vkey);
                node = node->next; 
        }
}


static void print_graph(struct r2_graph *graph)
{
        struct r2_listnode *node = r2_listnode_first(graph->vlist);
        struct r2_vertex *vertex = NULL; 
        while(node != NULL){
                vertex = node->data; 
                printf("\n[%d]=>", *(r2_uint64 *)vertex->vkey);
                print_edges(vertex);
                node = node->next; 
        }
}



static void print_bfstree(struct r2_bfsnode *root, r2_uint64 size)
{
        printf("\n BFS Tree: ");
        for(r2_uint64 i = 0; i < size; ++i){
                if(root[i].vertex != NULL){
                        printf("\n%d ==>", *root[i].vertex->vkey); 
                        for(r2_uint64 j = root[i].children.start; j < root[i].children.end;++j){
                                if(root[j].vertex != NULL)
                                        printf("%d ", *root[j].vertex->vkey);
                        }
                }
        }
}

static void print_dfstree(struct r2_dfstree *dfs)
{
        struct r2_dfsnode  *root    = dfs->tree;
        struct r2_dfsnode  *child   = NULL;
        struct r2_vertex   *vertex  = NULL;
        struct r2_listnode *head    = NULL;
        struct r2_entry entry = {.key = NULL, .data = NULL, .length = 0};
        printf("\n DFS Tree: ");
        for(r2_uint64 i = 0; i < dfs->ncount; ++i){
                vertex = root[i].vertex;
                if(vertex != NULL){
                        printf("\n%ld ==>", *vertex->vkey); 
                        head = r2_listnode_first(vertex->out); 
                        while(head != NULL){
                                vertex = head->data; 
                                entry.key = NULL; 
                                entry.data = NULL; 
                                entry.length = 0;
                                r2_robintable_get(dfs->positions, vertex->vkey, vertex->len, &entry);
                                child = entry.data;
                                if(child != NULL){
                                        if(child->parent == root[i].pos)
                                              printf("%ld ", *vertex->vkey);   
                                }

                                head = head->next;
                        }
                }
        }
}

static r2_ldbl relax(r2_ldbl a, r2_ldbl b)
{
        return a + b;
}

static void print_dfstree_distances(struct r2_dfstree *dfs)
{
        struct r2_dfsnode *root  = dfs->tree; 
        struct r2_vertex *source = root->vertex; 
        struct r2_vertex *dest   = NULL;
        struct r2_list *path = NULL;
        struct r2_listnode *head = NULL;
        r2_ldbl dist = 0;
        printf("\nShortest Path Tree: ");
        for(r2_uint64 i = 0; i < dfs->ncount; ++i){
                dest = root[i].vertex;
                dist = root[i].dist;
                if(dist == 0 || dist == INFINITY)
                        continue;
                printf("\n%c", *source->vkey);
                path = r2_graph_dfs_has_path_tree(dfs, source, dest);
                head = r2_listnode_first(path); 
                while(head != NULL){
                        dest = head->data;
                        if(dest != source) 
                                printf("=>%c", *dest->vkey);
                        head = head->next; 
                }
                printf(" = %.2lf", (double)dist);
                r2_destroy_list(path);
        }
}




/**
 * @brief                       Performs Dijkstra shortest path from the source vertex.
 * 
 * @param graph                 Graph.
 * @param src                   Source.
 * @param slen                  Source length.
 * @param rela                  Relaxation function.
 * @return struct r2_bfstree*   Returns shortest path tree.
 */
/*
struct r2_dfstree* r2_graph_dijkstra(struct r2_graph *graph, r2_uc *src, r2_uint64 slen,  r2_ldbl(*relax)(r2_ldbl, r2_ldbl))
{
        r2_uint16 FAILED = FALSE;
        struct r2_vertex *source = r2_graph_get_vertex(graph, src, slen); 
        if(source == NULL){
                FAILED = TRUE;
                goto CLEANUP; 
        }

        struct r2_dfstree *dfs             = malloc(sizeof(struct r2_dfstree)); 
        struct r2_dfsnode *tree            = malloc(sizeof(struct r2_dfsnode) * graph->nvertices);
        struct r2_robintable *positions    = r2_create_robintable(1, 1, 0, 0, .75, graph->vcmp, NULL, NULL, NULL, NULL, NULL);
        struct r2_robintable    *processed = r2_create_robintable(1, 1, 0, 0, .75, graph->vcmp, NULL, NULL, NULL, NULL, NULL);
        struct r2_pq *pq                   = r2_create_priority_queue(graph->nvertices, 0, cmp, NULL, NULL);
        if(dfs == NULL || tree == NULL || positions == NULL || processed == NULL || pq == NULL){
                FAILED = TRUE; 
                goto CLEANUP;
        }

        /*Initializing tree*/
        dfs->tree      = tree; 
        dfs->positions = positions; 
        dfs->ncount    = 0; 

        /*Initializing distances*/
        for(r2_uint64 i = 0; i < graph->nvertices; ++i){
                tree[i].vertex = NULL; 
                tree[i].pos    = 0;
                tree[i].state  = WHITE; 
                tree[i].dist   = INFINITY;
                tree[i].parent =  -1;   
                tree[i].start  = 0;
                tree[i].end    = 0;
        }

        struct r2_listnode *head  = NULL;
        struct r2_dfsnode  *root  = NULL;
        struct r2_dfsnode  *child = NULL;
        struct r2_edge   *edge    = NULL; 
        struct r2_vertex *dest    = NULL;
        struct r2_entry entry = {.key = NULL, .data = NULL, .length = 0};
        r2_uint64 count = 0;
        
        /*Initialize root*/
        tree[count].vertex   = source; 
        tree[count].state    = GREY;
        tree[count].dist     = 0;
        ++dfs->ncount;
        struct r2_locator *l = r2_pq_insert(pq, &tree[count]);
        struct r2_locator *m = NULL;
        if(l == NULL){
                FAILED = TRUE; 
                goto CLEANUP;
        }

        r2_robintable_put(processed, source->vkey, l, source->len);
        r2_robintable_get(processed, source->vkey, source->len, &entry);
        if(entry.key == NULL){
                FAILED = TRUE; 
                goto CLEANUP;
        }

        r2_robintable_put(positions, source->vkey, &tree[count], source->len);
        entry.key = entry.data = NULL; 
        r2_robintable_get(positions, source->vkey, source->len, &entry);
        if(entry.key == NULL){
                FAILED = TRUE; 
                goto CLEANUP;
        }

        while(r2_pq_empty(pq) != TRUE){
                l      = r2_pq_first(pq); 
                root   = l->data;
                source = root->vertex; 
                head   = r2_listnode_first(source->elist);
                while(head != NULL){
                        edge = head->data;
                        dest = edge->dest;
                        entry.key = entry.data = NULL; 
                        r2_robintable_get(processed, dest->vkey, dest->len, &entry);
                        if(entry.key == NULL){
                                ++dfs->ncount;
                                ++count;
                                tree[count].vertex = dest;
                                tree[count].pos    = count; 
                                tree[count].state  = GREY;
                                tree[count].dist   = relax(root->dist, edge->weight); /*possible custom function*/
                                tree[count].parent = root->pos; 
                                m =  r2_pq_insert(pq, &tree[count]);
                                r2_robintable_put(processed, dest->vkey, m, dest->len);
                                entry.key = entry.data = NULL; 
                                r2_robintable_get(processed, dest->vkey, dest->len, &entry);
                                if(entry.key == NULL){
                                        FAILED = TRUE; 
                                        goto CLEANUP;
                                                
                                }

                                r2_robintable_put(positions, dest->vkey, &tree[count], dest->len);
                                entry.key = entry.data = NULL; 
                                r2_robintable_get(positions, dest->vkey, dest->len, &entry);
                                if(entry.key == NULL){
                                        FAILED = TRUE; 
                                        goto CLEANUP;
                                }
                        }else{
                                m = entry.data;
                                entry.key = entry.data = NULL;
                                r2_robintable_get(positions, dest->vkey, dest->len, &entry);
                                child = entry.data;
                                if(child->state != BLACK){
                                        r2_ldbl dist = relax(root->dist, edge->weight);
                                        if(dist < child->dist){
                                                child->parent = root->pos;
                                                child->dist = dist;
                                                pq =  r2_pq_adjust(pq, m, 0);
                                        }
                                }

                        }
                        head = head->next;
                }
                root->state = BLACK;
                r2_pq_remove(pq, l);

        }

        CLEANUP:
                if(processed != NULL)
                        r2_destroy_robintable(processed);

                if(pq != NULL)
                        r2_destroy_priority_queue(pq);
                
                if(FAILED == TRUE && positions != NULL)
                        r2_destroy_robintable(positions);
                
                if(FAILED == TRUE && tree != NULL)
                        free(tree); 

                if(FAILED == TRUE && dfs != NULL)
                        free(dfs);

        assert(FAILED == FALSE);    
        return dfs;
}*/

/**
 * @brief                       Performs Dijkstra shortest path from the source vertex.
 * 
 * @param graph                 Graph.
 * @param src                   Source.
 * @param slen                  Source length.
 * @param rela                  Relaxation function.
 * @return struct r2_bfstree*   Returns shortest path tree.
 */
struct r2_dfstree* r2_graph_bellman_ford(struct r2_graph *graph, r2_uc *src, r2_uint64 slen,  r2_ldbl(*relax)(r2_ldbl, r2_ldbl))
{

}


/*Callback function used to compare vertices*/
static r2_int16 cmp(const void *a, const void *b)
{
        struct r2_bfsnode *c = a; 
        struct r2_bfsnode *d = b; 
        if(c->dist <= d->dist)
                return  0; 
        return 1;
}